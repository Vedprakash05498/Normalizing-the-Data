# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17jODiVlMMIQes8HucxZGZMiRhyLaMvSD
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
import numpy as np
warnings.filterwarnings('ignore')
# %matplotlib inline

df = pd.read_csv('winequality.csv')
df.head()

df.describe()

sns.distplot(df["free sulfur dioxide"])

sns.distplot(df['alcohol'])

## value / max_value
df_temp = df.copy()
df_temp['free sulfur dioxide'] = df_temp['free sulfur dioxide'] / df_temp['free sulfur dioxide'].abs().max()
sns.distplot(df_temp['free sulfur dioxide'])

df_temp['alcohol'] = df_temp['alcohol'] / df_temp['alcohol'].abs().max()
sns.distplot(df_temp['alcohol'])

# (value - min) / (max - min)
df_temp = df.copy()
df_temp['alcohol'] = (df_temp['alcohol'] - df_temp['alcohol'].min()) / (df_temp['alcohol'].max() - df_temp['alcohol'].min())
sns.distplot(df_temp['alcohol'])

# original_value = scaled_value * (max-min) + min
#Log Transformation
sns.distplot(df['total sulfur dioxide'])

df_temp = df.copy()
df_temp['total sulfur dioxide'] = np.log(df_temp['total sulfur dioxide']+1)
sns.distplot(df_temp['total sulfur dioxide'])

##Standardization of Data
## z-score method
# scaled_value = value - mean / std
# original_value = scaled_value * std + mean
sns.distplot(df['fixed acidity'])

sns.distplot(df['pH'])

scaled_data = df.copy()
## apply the formula
for col in ['fixed acidity', 'pH']:
    scaled_data[col] = (scaled_data[col] - scaled_data[col].mean()) / scaled_data[col].std()
sns.distplot(scaled_data['fixed acidity'])

sns.distplot(scaled_data['pH'])

from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
sc.fit(df[['pH']])
StandardScaler()
sc_data = sc.transform(df[['pH']])
sc_data = sc_data.reshape(-1)
sns.distplot(df['pH'])

sns.distplot(sc_data)

#Detect and Remove Outliers
df.describe()

sns.distplot(df['residual sugar'])

# to see outliers clearly
sns.boxplot(df['residual sugar'])

##Z-score method
# find the limits
upper_limit = df['residual sugar'].mean() + 3*df['residual sugar'].std()
lower_limit = df['residual sugar'].mean() - 3*df['residual sugar'].std()
print('upper limit:', upper_limit)
print('lower limit:', lower_limit)

# find the outliers
df.loc[(df['residual sugar'] > upper_limit) | (df['residual sugar'] < lower_limit)]

# trimming - delete the outlier data
new_df = df.loc[(df['residual sugar'] <= upper_limit) & (df['residual sugar'] >= lower_limit)]
print('before removing outliers:', len(df))
print('after removing outliers:',len(new_df))
print('outliers:', len(df)-len(new_df))

sns.boxplot(new_df['residual sugar'])

# capping - change the outlier values to upper (or) lower limit values
new_df = df.copy()
new_df.loc[(new_df['residual sugar']>=upper_limit), 'residual sugar'] = upper_limit
new_df.loc[(new_df['residual sugar']<=lower_limit), 'residual sugar'] = lower_limit

sns.boxplot(new_df['residual sugar'])

len(new_df)

##IQR method
q1 = df['residual sugar'].quantile(0.25)
q3 = df['residual sugar'].quantile(0.75)
iqr = q3-q1
q1, q3, iqr

upper_limit = q3 + (1.5 * iqr)
lower_limit = q1 - (1.5 * iqr)
lower_limit, upper_limit

sns.boxplot(df['residual sugar'])

# find the outliers
df.loc[(df['residual sugar'] > upper_limit) | (df['residual sugar'] < lower_limit)]

# trimming - delete the outlier data
new_df = df.loc[(df['residual sugar'] <= upper_limit) & (df['residual sugar'] >= lower_limit)]
print('before removing outliers:', len(df))
print('after removing outliers:',len(new_df))
print('outliers:', len(df)-len(new_df))

sns.boxplot(new_df['residual sugar'])

# capping - change the outlier values to upper (or) lower limit values
new_df = df.copy()
new_df.loc[(new_df['residual sugar']>upper_limit), 'residual sugar'] = upper_limit
new_df.loc[(new_df['residual sugar']<lower_limit), 'residual sugar'] = lower_limit
sns.boxplot(new_df['residual sugar'])